ft("Literal zero", "");
0;

ft("Literals", "");
42;
101;
1010;





//Create all with defaults





ft("Create int", "");
var x int;

ft("Create 2 int");
var x int;
var y int;

ft("Xtra--create 2 int short");
var x, y int;


ft("Create and state", "");
var x int;
x;

ft("Set x to 0", "");
var x int;
x = 0;

ft("Set x to itself", "");
var x int;
x = x;

ft("Create and set 2 ints", "");
var x int;
var y int;
y = x;



ft("Create and set 3 ints", "");
var x int;
var y int;
var z int;
y = x;
z = y;

ft("Create and set ints to each other", "");
var x int;
var y int;
x = y;
y = x;

ft("Create 3 ints", "");
var x int;
var y int;
var z int;
x = y;
y = x;
x = z;
z = x;
y = z;
z = y;





ft("Boolean", "");
false;
true;

ft("String", "");
"";
"str";
"a";


ft("Boolean and String literals", "");
true;
false;
"str";
"";

ft("Create bool", "");
var b bool;


ft("Create string", "");
var str string;






//Create collections

ft("Create array", "");
var x [1]int;

ft("Create array 2", "");
var x [2]int;
var y [7]int;

ft("Create comp array", "");
var x[1][1]int;
var y[7][1]int;
var z[1][7]int;

ft("Array assign", "");
var x[7]int;
var y[7]int;
x = y;
y = x;

ft("Array index", "");
var x[3]int;
x[2];
x[0];

ft("Array index assign");
var x[3]int;
x[0] = 0;

//slice

ft("Create slice", "");
var x []int;

ft("Slice 2", "");
var x []int;
var y []bool;

ft("Slice composite", "");
var x [][]int;
var y [][][]bool;

ft("Slice assign", "");
var x, y []int;
x = y;
y = x;

ft("Slice extend");
var x []int;
x[0] = 10;
x[1] = 42;

ft("Slice index");
var x []int;
x[0] = 20;
x[0];

//map

ft("Create map", "");
var x [map]int;

ft("Map 2", "");
var x [map]bool;

ft("Comp map", "");
var x [map][map]int;
var y [map][map][map]bool;

ft("Map assign", "");
var x, y [map]int;
x = y;
y = x;
var i[map][map]bool;
var j[map][map]bool;
i = j;
j= i;


ft("Map index", "");
var x [map]int;
x["key"];
x["k"] = 0;


//tuple

ft("Tuple", "");
var t (int, int);

ft("Tuple 2", "");
var x (int, int, int);
var y (int, bool);

ft("Tuple composite", "");
var x (int, (int, bool));

ft("Tuple assign", "");
var x, y (int, int);
x = y;
y = x;

ft("Tuple index (both syntax)", "");
var x (int, int);
x[0];
x[0] = 0;
x.1;
var y ((int, int), int);
y[0][1] = 0;
y[1] = 0;

//Pointer

ft("Pointer", "");
var p *(int);

ft("Pointer 2", "");
var x *(int, int);
var y *(int, bool);
var z *(bool);

ft("Comp pointer", "");
var p *(*(int), bool);
var p2 *(*(int));

ft("Pointer assign");
var x *(int);
var y *(int);
x = y;
y = x;

ft("Pointer index (literal needed)");
var p *(int, int);
p = *(1, 4);
p[0];
p[0] = 10;
p[1];


// Struct

ft("Struct");
var s {a: int, b: bool};

ft("Struct index get", "0 false");
var s {a: int, b: bool};
print(s["a"], s["b"]);




// Expressions

ft("plus", "");
0 + 0;

ft("Plus 2", "");
1 + 2 + 3;
"con" + "cat";

ft("Equal", "");
0 == 0;

ft("Equal 2", "");
0 == 1;
true == false;
true == true;
"abc" == "abcdef";












//PRINT

ft("Print", "");
print("");

ft("Print zero", "0");
print(0);

ft("Print two", "42 101");
print(42, 101);

ft("Print three", "23 23 23");
print(23, 23, 23);

ft("Print twice", "77");
print(7);
print(7);

ft("Mixed", "1 23");
print(1, 2);
print(3);

ft("Print str", "str");
print("str");

ft("Print var", "23");
var x int;
x = 23;
print(x);







ft("Int copies by value", "23 42");
var x int;
var y int;
x = 23;
y = x;
y = 42;
print(x, y);


ft("Create and tuple destructure", "42 true");
var x int;
var y bool;
(x, y) = (42, true);
print(x, y);

ft("Short declaration", "42 true str 98.5");
i := 42;
b := true;
s := "str";
d := 98.5;
print(i, b, s, d);

ft("Short destructure", "101 false");
(a, b) := (101, false);
print(a, b);

ft("Multi short declaration:", "1 5 10");
a, b, c := 1, 5, 10;
print(a, b, c);

ft("Short declaration and created", "42 42 true true");
x := 42;
var y int;
y = x;
x = y;
print(x, y, x == y, y == x);





ft("Multi swap:", "101 42");
x, y := 42, 101;
x, y = y, x;
print(x, y);












ft("Create 2 array", "[0 0] [0 0] true");
var a [2]int;
var b [2]int;
a = b;
b = a;
print(a, b, a == b);

ft("Xtra--1 and zero size array", "[0] []");
var a1 [1]int;
var a2 [0]int;
print(a1, a2);

ft("Xtra--variable array bounds", "[0 0][0 0 0]");
var x int;
x = 2;
var y [x]int;
print(y);
x = 3;
var y2 [x]int;
print(y2);

ft("Create array and set", "[42 101]");
var na [2]int;
na[0] = 42;
na[1] = 101;
print(na);

ft("Create/set 2-dimensional array", "[[0 0 0] [0 0 0]][[0 0 20] [0 0 0]]");
var a [2][3]int;
print(a);
a[0][2] = 20;
print(a);

ft("Multi", "[[42 0] [0 0]] [42 0][[42 0] [0 101]] [0 101]");
var a [2][2]int;
var b [2]int;
b[0] = 42;
a[0] = b;
print(a, b);
a[1][1] = 101;
b = a[1];
print(a, b);


ft("Array copies on set", "[23] [42][[42 23] [202 0]] [[42 23] [202 101]]");
var a[1]int;
var b[1]int;
a[0] = 23;
b = a;
b[0] = 42;
   print(a, b);

var c[2][2]int;
var d[2][2]int;
c[0][0] = 42;
c[0][1] = 23;
c[1][0] = 202;
d = c;
d[1][1] = 101;
print(c, d);




ft("Create 2 slice", "false[] [] true");
var a[]int;
var b[]int;
print(a == b);
a = b;
b = a;
print(a, b, a == b);



ft("Create slice and set", "[42]");
var a[]int;

a[0] = 42;
print(a);

ft("Create/set 2-dimensional slice", "[][[42]][[42] [101 202]]");
var s[][]int;
print(s);
s[0][0] = 42;
print(s);
s[1][0] = 101;
s[1][1] = 202;
print(s);


ft("Slice shares", "[42] [42][101] [101]");
var s []int;
s[0] = 42;
var t []int;
t = s;
print(s, t);
t[0] = 101;
print(s, t);





ft("Xtra--slice", "[101][][42]");
var s[]int;
s[0] = 101;
print(s);
s = ...[];
print(s);
s[0] = 42;
print(s);

ft("Nested nil slice", "[[42]][[101]]");
var s[][]int;
s[0] = ...[42];
print(s);

//s = ...[...[]];
//print(s);

s[0] = ...[101];
print(s);


ft("Array slice mixes", "[[] []] [] ,[[] [42]] [[0 101]][[0 101] [202 0]]");
var asm [2][]int;
var asm2 [][2]int;
print(asm, asm2, ",");
asm[1][0] = 42;
asm2[0][1] = 101;

print(asm, asm2);
asm2[1][0] = 202;
print(asm2);

ft("Xtra array/slice", "[[] []] ,[[] [[0 42]]] ,[] ,[[[] [101]]] ,");
var arsl [2][][2]int;
print(arsl, ",");
arsl[1][0][1] = 42;
print(arsl, ",");
var arsl2 [][2][]int;
print(arsl2, ",");
arsl2[0][1][0] = 101;
print(arsl2, ",");

ft("Array with nil slice", "[[42]]");
   var ar [1][]int;
   ar = [...[]];
ar[0] = ...[42];
   print(ar);


ft("Create tuple", "(0 false)(0 0)");
var t (int, bool);
print(t);
var t2 (int, int);
print(t2);

ft("Create 2 tuples", "(0 false) (0 false) true");
var t (int, bool);
var t2 (int, bool);
t = t2;
t2 = t;
print(t, t2, t == t2);

ft("Create tuple and set", "(42 true)");
var t (int, bool);
t[0] = 42;
t[1] = true;
print(t);

ft("Create/set tuple of tuples", "((0 false) (false 0))((42 false) (true 0))");
var tt ((int, bool), (bool, int));
print(tt);
tt[0][0] = 42;
tt[1][0] = true;
print(tt);

ft("Tuple copies", "(42 0) (42 101)");
var t (int, int);
var t2 (int, int);
t[0] = 42;
t2 = t;
t2[1] = 101;
print(t, t2);


ft("Stress-mixed", "");
var v [2]((int, bool, [7](int, bool), [3][]int));

ft("Create pointer", "*()*()");
var v *(int, bool);
print(v);
var v2 *(int);
print(v2);

ft("Create and set pointer", "*()*(true 42)*()*(false 101)*(str)");
var v *(bool, int);
print(v);
v = *(true, 42);
print(v);
v = *();
print(v);
v = *(false, 101);
print(v);
var v2 *(string);
v2 = *("str");
print(v2);

ft("Nil pointers", "*()*(*() true)*(P false) *(42)");
var v *(*(int), bool);
print(v);
v = *(*(), true);
print(v);
v = *(*(42), false);
print(v, v[0]);



ft("Create 2 pointers", "*(false 101) *(false 101) true");
var v *(bool, int);
var v2 *(bool, int);
v = *(false, 101);
v2 = v;
v = v2;
print(v, v2, v == v2);

ft("Composite pointers", "*()*(42 true P) *(101 202)*(303 false *())");
var v *(int, bool, *(int, int));
print(v);
v = *(42, true, *(101, 202));
print(v, v[2]);
v = *(303, false, *());
print(v);

ft("Pointers of single", "45");
var v *(int);
var v2 *(int);
v = *(42);
v2 = *(3);
print(v.0 + v2[0]);

ft("Pointer shares", "*(42) *(42)*(101) *(101)");
var p1 *(int);
p1 = *(42);
var p2 *(int);
p2 = p1;
print(p1, p2);
p2[0] = 101;
print(p1, p2);



ft("Self", "*(P false) *(*() true) *()*(P true) *(*() false) *()");
var rec2 *(self, bool);
rec2 = *(*(*(), true), false);
print(rec2, rec2[0], rec2[0][0]);
rec2[1] = true;
rec2[0][1] = false;
print(rec2, rec2[0], rec2[0][0]);










ft("Pointers and slices", "[][*()][*() P] *() *(42 true)");
var ps []*(int, bool);
print(ps);
ps[0] = *();
print(ps);
ps[1] = *(42, true);
print(ps, ps[0], ps[1]);

ft("Slices and pointers", "*()*([] true)[]*([101] true)");
var sp *([]int, bool);
print(sp);
sp = *(...[], true);
print(sp);
print(sp[0]);
sp[0][0] = 101;
print(sp);

ft("Tuple with nil pointer", "(P true)");
var t (*(int), bool);

t = (*(), true);
t[0] = *(42);
print(t);






ft("Maps share", "{a:42 z:101} {a:42 z:101}");
var m[map]int;
var m2[map]int;

m["a"] = 42;
m2 = m;
m2["z"] = 101;
print(m, m2);

ft("Composite maps", "{}{a:{}}{a:{z:42}}{a:{z:42} k:{k2:101}}");
var m[map][map]int;
print(m);
m["a"] = {};
print(m);
m["a"]["z"] = 42;
print(m);
m["k"]["k2"] = 101;
print(m);

ft("Maps and pointers", "");
var t *([map]int, bool);
t = *({}, true);
t[0]["b"] = 101;

ft("map", "");
var t [map][map]int;
t = {"a": {}};
t["a"] = {"b": 5};






ft("Create decimal", "0");
var d decimal;
print(d);








ft("Stress--named array", "");
type tA [3][2][3][2]decimal;
type tB [2][5]tA;
type tC [2]tA;
var vA tA;
var vB tB;
var vC tC;


ft("Named type test", "0");
type tInt int;
var x tInt;
print(x);

ft("Chained named type", "false");
type tA bool;
type tB tA;
var x tB;
print(x);

ft("Create and set named type", "101.5");
type t decimal;
var d t;
d = 101.5;
print(d);


ft("Create and set differently named types", "101 101 42 42");
type t int;
var x1 t;
x1 = 101;
var x2 int;
x2 = x1;
print(x1, x2, "");
var xA int;
xA = 42;
var xB t;
xB = xA;
print(xA, xB);

ft("Create and set two named types derived from int", "202 202");
type tA int;
type tB int;
var vA tA;
vA = 202;
var vB tB;
vB = vA;
print(vA, vB);

ft("Xtra--named", "true true true0 0 0");

type tA int;
type tB tA;
type tC tB;
var vA tA;
var vB tB;
var vC tC;
print(vA == vB, vA == vC, vB == vC);
vA = vB;
vB = vA;
vA = vC;
vC = vA;
vB = vC;
vC = vB;
print(vA, vB, vC);


ft("Short declaration and named", "101 101 true");
s := 101;
type t int;
var x t;
x = s;
s = x;
print(s, x, s == x);





ft("Named slice", "[[42]]");
type ts []int;
type tsa []ts;

var v tsa;
v[0][0] = 42;
print(v);


ft("Named tuple", "(105 0)((0 0) 0)");
type t (int, int);
var v t;
v[0] = 105;
print(v);
type t2 (t, int);
var v2 t2;
print(v2);




ft("Named", "[0 0][42 0][42 0] [42 0] true");
type t [2]int;
var v t;
print(v);
v[0] = 42;
print(v);
var v2 [2]int;
v2 = v;
v = v2;
print(v, v2, v == v2);

ft("Xtra--named", "[[0 42] [0 0]][[0 42] [0 0]] [[0 42] [0 0]] true");
type t [2]int;
var v [2]t;
v[0][1] = 42;
print(v);

var v2 [2][2]int;
v2 = v;
v = v2;
print(v, v2, v == v2);



//Control flow

ft("Bare if", "");
if true ;
if false ;

ft("If other", "");
if true 5;
if false 10;

ft("Else", "");
if false ; else ;





ft("Block", "");
{}






ft("While", "");
while false {}

ft("If and while", "");
if false ;
  else
while false {}







//Printing
ft("Print one item", "101");
print(101);

ft("Print multiple items", "23 42 101");
print(23, 42, 101);

ft("Print multiple times", "125");
print(1);
print(2);
print(5);


ft("Print literals IBSD", "42 true str 1.5");
print(42, true, "str", 1.5);

ft("Print", "a \\ slash");
print("a \\ slash");






// Array literal
ft("Array literal", "");
[0];

ft("Array literal 2", "");
[true];
["str"];
[1, 2];
[1, 5, 10];

ft("Array literal comp", "");
[[0]];

// Slice literal
ft("Slice literal", "");
...[];

ft("Slice literal 2", "");
...[true];
...["str"];
...[1, 2];
...[1, 5, 10];

ft("Slice literal comp", "");
...[...[0]];


// Map literal
ft("Map literal", "");
{}

ft("Map literal 2", "");
{"a": "b", "c": "d", "e": "val"};
{"key": 42};

ft("Map compos", "");
{"out": {"in": 5}};

// Tuple literal

ft("Tuple", "");
();

ft("Tuple 2", "");
(1, 5);

ft("Tuple composite", "");
((1, true, false), 5);

// Pointer literal

ft("Pointer", "");
*();

ft("Pointer 2", "");
*(3);
*(false, true);
*(10, 11, 102);

ft("Pointer composite", "");
*(*(true, false), 1, 5, "abc");

// Mixes

ft("Arrays null", "");
[*(), *(), *()];
[...[], ...[]];
[{}, {}];

ft("Array mix", "");
[*(42), *(101), *()];
[...[], ...[(1, 4)]];
[{"bcd": false}, {}, {"a": true}];

ft("Slice of null-types", "");
...[*(101), *(), *(202)];

ft("Map of null-types", "");
{a: *(), b: *(), c: *(5)};
{a: *(), b: *()};
{a: ...[10, 2], b: ...[5], c: ...[]};


ft("Composite all", "");
(1, 5, 101, [1, 5], ...[10, 12], {"key": 42}, *(12, 20));

ft("Print arrays", "[23] [true true] [aa bb cc] [0.5 1.5]");
print([23], [true, true], ["aa", "bb", "cc"], [0.5, 1.5]);

ft("Print slices", "[10] [23 45] [ab bc]");
print(...[10], ...[23, 45], ...["ab", "bc"]);

ft("Print tuple", "(1 true 10.5)");
print((1, true, 10.5));

ft("Print pointer", "*(5 *() true)");
print(*(5, *(), true));

ft("Print single element object", "{foo:42}");
print({"foo": 42});


ft("Recursive named", "*()*(*() true) *()*(P true) *(*() false)");
type node *(node, bool);
var n node;
print(n);
n = *(*(), true);
print(n, n[0]);
n[0] = *(*(), false);
print(n, n[0]);










ft("Create map", "{answer:true} true false");
var newMap [map]bool;
newMap["answer"] = true;
print(newMap, key(newMap, "answer"), key(newMap, "not"));











ft("Short slice equals", "falsetrue[10] [5] false false");
s := ...[5];
a := ...[5];
print(a == s);
a = s;
print(a == s);
a = ...[10];
print(a, s, a == s, s == a);




ft("Create array of string", "[alpha bravo charlie]");
var arStr [3]string;
arStr[0] = "alpha";
arStr[1] = "bravo";
arStr[2] = "charlie";
print(arStr);


ft("Deep nesting and length", "[(0 {} [[0 0 0 0 42]])] 1 5 [(42 {key:true} [12 101]) (101 {aap:false} [202])]");
var cx [](int, [map]bool, [][5]int);
cx2 := ...[(42, {"key": true}, ...[12, 101])];
cx2[1] = (101, {"aap": false}, ...[202]);
cx[0][2][0][4] = 42;
print(cx, len(cx), len(cx[0][2][0]), "");
print(cx2);

ft("Nested types, declared", "[true] [[true] [] []]");
var cdn42 [3][]bool;
var cdns42 []bool;
cdns42[0] = true;
cdn42[0] = cdns42;
print(cdns42, cdn42);

ft("Nested types, declared deep array", "[[[0 0 0 0] [0 0 42 0] [0 0 0 0]] [[0 0 0 0] [0 0 0 0] [0 0 0 0]]]");
var ntdda [2][3][4]int;
ntdda[0][1][2] = 42;
print(ntdda);

ft("Short declaration slice", "[10 23 42 101] [10 23 42 101]");
sda := ...[10, 23, 42, 101];
print(sda, "");
var sds []int;
sds = sda;
print(sds);

ft("Short declaration nested slice", "[[2 1] [21 23 101]][[2 1] [21 23 101]]");
sdns := ...[...[2, 1], ...[21, 23, 101]];
print(sdns);
var sdns2 [][]int;
sdns2 = sdns;
print(sdns2);
ft("Slicing can be repeated and still shares both ways", "[101 42] [101 42][201 42] [201 42][201 301] [201 301]");
s := ...[101, 42];
s2 := s[:][:][:];
print(s, s2);
s2[0] = 201;
print(s, s2);
s[1] = 301;
print(s, s2);

ft("Assign smaller slice to slice plus length", "[202 302] 2");
assts := ...[24, 30, 101];
assts = [202, 302][:];
print(assts, len(assts));

ft("Assign larger slice to slice plus length", "[202 302 502] 3");
alsts := ...[24, 30];
alsts = ...[202, 302, 502];
print(alsts, len(alsts));

ft("Print open interval 1 to 5", "[1 2 3 4]");
print(1:5);

ft("Print closed interval 11 through 13", "[11 12 13]");
print(11@13);

ft("Create array of ints", "[10 14 23 42 101 201]");
aInt := [10, 14, 23, 42, 101, 201];
print(aInt);





//ft("Create literal of pointer and nil", "[P N]");
//ar := [*(42), *()];
//print(ar);

ft("Pointer as nullable it:", "*() true *(42) false");
var pi *(int);
print(pi, pi == *(), "");
pi = *(42);
print(pi, pi == *());




//ft("Create map to pointer and nil", "{a:P b:N}");
//m := {"a": *(101), "b": *()};
//print(m);
ft("Array slicing", "[] [] [12 23 42 101] [12] [101]");
ar := [12, 23, 42, 101];
print(ar[0:0], ar[3:3], ar[:], ar[0:1], ar[3:4]);
ft("String slicing.", " , beta , b , a");
str := "beta";
print(str[0:0], ",", str[:], ",", str[0:1], ",", str[3:4]);
ft("Convert array to slice", "[42 101] [42 101]");
var ar[2]int;
ar[0] = 42;
ar[1] = 101;
var s[]int;
s = ar[:];
print(ar, s);
ft("Copy to slice of ints", "[10 14 23 42 101 201]");
aInt := [10, 14, 23, 42, 101, 201];
sInt := aInt[:];
print(sInt);

ft("Add 666 to slice of ints", "[10 14 23 42 101 201 666]");
aInt := [10, 14, 23, 42, 101, 201];
sInt := aInt[:];
sInt[len(sInt)] = 666;
print(sInt);

ft("Change first element to 7", "[7 14 23 42 101 201 666]");
aInt := [10, 14, 23, 42, 101, 201];
sInt := aInt[:];
sInt[len(sInt)] = 666;
sInt[0] = 7;
print(sInt);

ft("Get second element", "14");
aInt := [10, 14, 23, 42, 101, 201];
sInt := aInt[:];
print(sInt[1]);








//Block
ft("Block", "");
{}

ft("Block 2", "");
{
    0;
}
{
    true;
}
{
    5;
    10;
    false;
}

   ft("Block nest", "");
{
    {}
}

   {
    {
        {
        }
    }
}

   ft("Blocks share scope", "");
{
    var x int;
}
x;









// function isolated

ft("Function");
func f() {}

ft("Function 2");
func f() {}
func g() {}

ft("Function return");
func f() int {}

ft("Function parameter");
func f(a int) {}

ft("2 parameters");
func f(a int, b int) {}

ft("Parameter and return (reject?)");
func f(a int) int {}

ft("Function call");
func f() {}


f();

ft("Function call 2");
func fA(a int) {}
func fB(a int, b int) {}
func fC(a, b int) {}
fA(0);
fB(0, 0);
fC(0, 0);

ft("Function call 3");
func f() int {return 0;}
f();

ft("Call and return");
func f(a int) int {
    return 0;
}
var x int;
x = f(0);

ft("Call and return bools");
func f(a bool) bool {
    return true;
}
var x bool;
x = f(true);

ft("Basics in function");
func f() {
    0;
    42;
    var x int;
    x = 0;
}
f();

ft("Variadic");
func f(v ...int) {}
f(0, 5, 10);








ft("decimal + - * /", "6.6 -4.4 6.05 0.2");
DA := 1.1;
DB := 5.5;
print(DA + DB, DA - DB, DA * DB, DA / DB);

ft("Global int in header", "3");
GLOB := 3;
func giih(ar [GLOB]bool) {
    print(len(ar));
}
var glob [GLOB] bool;
giih(glob);


ft("Array copies in call", "23");
func arFunc(ar [1]int) {
    ar[0] = 42;
}
var arF[1]int;
arF[0] = 23;
arFunc(arF);
print(arF[0]);


ft("Slice shares in call", "[201 101]");
func slFunc(s []int) {
    s[0] = 201;
}
var slf []int;
slf = ...[23, 101];
slFunc(slf);
print(slf);


ft("Map shares in call", "{aap:101}");
func mFunc(m [map]int) {
    m["aap"] = 101;
}
mapShare := { "aap": 42};
mFunc(mapShare);
print(mapShare);


ft("Tuple", "(0 false )");
var tup23 (int, bool, string);
print(tup23);

ft("Tuple copies", "(42 false) (42 true)");
var tup (int, bool);
var tup2 (int, bool);
tup[0] = 42;
tup2 = tup;
tup2[1] = true;
print(tup, tup2);

ft("Tuple assignments", "([3 5] [aap noot])");
var tup2 ([]int, []string);
tup2[0] = ...[3, 5];
tup2[1] = ["aap", "noot"][:];
print(tup2);


ft("Tuple short declaration", "true 42 1.5 (42 true str 1.5)");
tup := (42, true, "str", 1.5);

print(tup[1], tup[0], tup[3], tup);

ft("Set tuple", "23 false");
tup := (42, true, "str", 1.5);
tup[0] = 23;
tup[1] = false;
print(tup[0], tup[1]);

ft("Compound add array, tuple, map", "[30 23] 4.5 {aap:201}");
caAr := [10, 23];
caAr[0] += 20;
caTu := (100, 1.5);
caTu[1] += 3.0;
caMa := {"aap": 101};
caMa["aap"] += 100;
print(caAr, caTu[1], caMa);

ft("Postfix minus array tuple, map", "49 100 22");
pfA := [50];
pfT := (101, "boo");
pfM := {"aaa": 23};
pfA[0]--;
pfT[0]--;
pfM["aaa"]--;
print(pfA[0], pfT[0], pfM["aaa"]);

ft("Compound equals", "true false");
ceAr1 := [1, 5, 23];
ceAr2 := [1, 5, 23];
ceAr3 := [1, 7, 23];
print(ceAr1 == ceAr2, ceAr2 == ceAr3);



ft("Map returns zero value with no key", "0, false");
var mrz [map]int;
print(mrz["a"]);
print(",", key(mrz, "a"));

ft("Tuple equals", "true false");
teTup := (5, "aap", false);
teTup2 := (5, "aap", false);
teTup3 := (23, "aap", false);
print(teTup == teTup2, teTup == teTup3);

ft("Global ar", "[1 5]");
gar := [1, 5];
func garf() {
    gar = [10, 12];
}
print(gar);

ft("Short declaration copies integer", "5 5,10 5");
sdci1 := 5;
sdci2 := sdci1;
print(sdci1, sdci2);
print(",");
sdci1 = 10;
print(sdci1, sdci2);


ft("Slicing shares", "[1 777 101 202] [777 101]");
ssAr1 := ...[1, 10, 101, 202];
ssAr2 := ssAr1[1@2];
ssAr2[0] = 777;
print(ssAr1, ssAr2);

ft("Slice of arrays does not share (bug)", "[[23]] [42]");
var j [][1]int;
j[0] = [23];
var k [1]int;
k = j[0];
k[0] = 42;
print(j, k);


ft("Slice to slice shares", "[101 23 42] [101 23 42]");
sss := ...[7, 23, 42];
sss2 := sss[:];
sss2[0] = 101;
print(sss, sss2);

ft("Array to slice copies (fix)", "[7 42] [101 42]");
ar := [7, 42];
s := ar[:];
s[0] = 101;
print(ar, s);

ft("Slice of arrays", "[[0 42] [101 0]] [[0 42] [0 42]] [[202 42] [0 42]]");
var soa [][2]int;

soa[0][1] = 42;
soa[1][0] = 101;
print(soa, "");
soa[1] = soa[0];
print(soa, "");
soa[0][0] = 202;
print(soa);

ft("Multi-dimensional array of int", "[[0 0 0] [0 0 42]]");
var mda [2][3]int;
mda[1][2] = 42;
print(mda);


ft("Multi-dimensional tuple", "([0 0 42 0 0] (true 101))");
var mdt ([5]int, (bool, int));
mdt[0][2] = 42;
mdt[1][1] = 101;
mdt[1][0] = true;
print(mdt);


ft("Multi-dimensional tuple set compound type", "([0 0 42 0 0] (true 202))");
var mdt ([5]int, (bool, int));
mdt[0][2] = 42;
mdt[1][1] = 101;
mdt[1][0] = true;
var mdt2 ([5]int, (bool, int));
mdt[1] = (true, 202);
print(mdt);


ft("Deeply nested type", "[(false 0 {}) (false 0 {})][(false 0 {}) (false 0 {aap:(42 noot)})]");
var dnt [2](bool, int, [map](int, string));
print(dnt);
dnt[1][2]["aap"] = (42, "noot");
print(dnt);

ft("Pointer", "*() *(42)");
var x *(int);
x = *();
print(x, "");
x = *(42);
print(x);

ft("Tuple of pointer", "(*()) (*())(P)");
var tup (*(int));
print(tup, "");
tup = ^(*());
print(tup);
tup = ^(*(42));
print(tup);




ft("Pointer compare", "false true*(4) *(4) *(4)false true*(4) *(12) *(12)");
x := *(4);
y := *(4);
z := y;
print(x == y, y == z);
print(x, y, z);
y[0] = 12;
print(x == y, y == z);

print(x, y, z);





ft("Assignability of recursive pointers", "*(42 *()) *(42 *())");
var point1 *(int, self);
var point2 *(int, self);
point1 = *(42, *());
point2 = point1;
print(point1, point2);

//point2 = *(101, point2);
//print(point1, point1[1], point2);

ft("Pointer shares", "*(101 42) *(101 42)");
var p *(int, int);
var p2 *(int, int);
p = *(23, 42);
p2 = p;
p2[0] = 101;
print(p, p2);

ft("Function copies pointer", "*(23)*(23)*(202)");
func f(p *(int)) {
  p = *(10);
}
func g(p *(int)) {
  p[0] = 202;
}
var z *(int);
z = *(23);
   print(z);
f(z);
print(z);
g(z);
print(z);



ft("Pointer in tuple", "(0 *()) (0 P) *(true *()) ");
var tup (int, *(bool, self));
print(tup, "");
tup[1] = *(true, *());
print(tup, "");
print(tup[1], "");

ft("Nested tuple short", "(4 (10 P))(10 P)*(12 *())");
x := (4, (10, *(12, *())));
print(x);
print(x[1]);
print(x[1][1]);




ft("Bubble sort", "[1 20 101 202 1081]");
bub := [1, 1081, 20, 101, 202];

var i int;
var j int;
for i = range 0:len(bub) - 1 {
    for j = len(bub) - 1; j > i; j-- {
      if bub[j] < bub[j - 1] {
        bub[j - 1], bub[j] = bub[j], bub[j - 1];
      }
    }
}
print(bub);




ft("Binary search tree", "1 2 3 5 5 5 10 ");
var i int;
var mbst *(self, int, self);
func tree_insert(x int) {
    if mbst == *() {
            mbst = *(*(), x, *());
            return;
    }
        cur := mbst;
        loop {
            if i < cur[1] {
                if cur[0] == *() {
                    cur[0] = *(*(), i, *());
                    break;
                } else {
                    cur = cur[0];
                    continue;
                }
            } else if i >= cur[1] {
                if cur[2] == *() {
                    cur[2] = *(*(), i, *());
                    break;
                } else {
                    cur = cur[2];
                    continue;
                }
            }
            debug();
    }
}
for i = range [1, 5, 5, 5, 10, 2, 3] {
    tree_insert(i);
}
func dfs(node  *(self, int, self)) {
    if node == *() {
        return;
    }
    dfs(node[0]);
    print(node[1], "");
    dfs(node[2]);
}
dfs(mbst);



ft("Linked list", "5 8 23 ");
var LL *(int, self);
LL = *(5, *());
base := LL;

LL[1] = *(8, *());

LL = LL[1];
LL[1] = *(23, *());
func pll(node *(int, self)) {
    if node == *() {
        return;
    }
    print(node[0], "");
    pll(node[1]);
}
pll(base);


ft("Nested pointer types, depth and flat", "*(aap *() P)*(noot *() *())");
npt := *("aap", *(), *("noot", *(), *()));
print(npt);
print(npt[2]);


//ft("Doubly linked list", "*(*() 5 P)*(P 7 *())*(*() 5 P)");
//var dll *(self, int, self);
//dll = *(*(), 5, *());
//dll[2] = *(dll, 7, *());
//print(dll);
//print(dll[2]);
//print(dll[2][0]);

ft("", "
Positives ok.
");

println("");
println("Positives ok.");




ft("", "");











































ft("Named type test", "5");
type tInt int;
var x tInt;
x = 5;
print(x);



ft("Named type tuple string", "(foo bar)");
type tTuple (string, string);
var x tTuple;
x[0] = "foo";
x[1] = "bar";
print(x);
ft("Named type equality", "12 12");
type tInt int;
var x tInt;
var y tInt;
x = 12;
y = x;
print(x, y);
ft("Named type array equality", "true false");
type tArray [2]int;
var a tArray;
var b tArray;
print(a == b, "");
a[0] = 23;
print(a == b, "");
//ng("");
