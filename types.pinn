//func ec() {
//    println();
//}
func conc(d string, v string) string {
    return d + "!" + v + "#";
}

//func ft(d string, v string) {
//print(conc(d, v));
//}

func brak(s int) {
    print("<");
    print(s);
    print(">");
}

ft("Create int", "0");
var x int;
print(x);

ec();ft("Print empty array", "[]");
var empty [0]int;
print(empty);

ec();ft("Print singleton array", "[23]");
print([23]);

ec();ft("Print two in array", "[101 777]");
print([101, 777]);

ec();ft("Print single element object", "{foo:42}");
print({"foo": 42});

ec();ft("Create and set to 10", "10");
var x2 int;
x2 = 10;
print(x2);

ec();ft("Create bool", "false");
var b bool;
print(b);

ec();ft("Create string", "");
var str string;
print(str);

ec();ft("Set string", "value");
var str2 string;
str2 = "value";
print(str2);

ec();ft("Short declaration", "true");
shortBool := true;
print(shortBool);

ec();ft("Create map", "{answer:true} true false");
var newMap [map]bool;
newMap["answer"] = true;
print(newMap, key(newMap, "answer"), key(newMap, "not"));

ec();ft("Create slice", "[777]");
var newSlice [slice]int;
newSlice[0] = 777;
print(newSlice);

ec();ft("Create array", "aap");
var newArray [3]string;
newArray[1] = "aap";
print(newArray[1]);

ec();ft("Create array of string", "[alpha bravo charlie]");
var arStr [3]string;
arStr[0] = "alpha";
arStr[1] = "bravo";
arStr[2] = "charlie";
print(arStr);

ec();ft("Short declaration slice", "[10 23 42 101]");
sda := [10, 23, 42, 101];
print(sda);

ec();ft("Print open interval 1 to 5", "[1 2 3 4]");
print(1:5);

ec();ft("Print closed interval 11 through 13", "[11 12 13]");
print(11@13);

ec();ft("Create array of ints", "[10 14 23 42 101 201]");
aInt := [10, 14, 23, 42, 101, 201];
print(aInt);

ec();ft("Copy to slice of ints", "[10 14 23 42 101 201]");
sInt := aInt[:];
print(sInt);

ec();ft("Add 666 to slice of ints", "[10 14 23 42 101 201 666]");
sInt[len(sInt)] = 666;
print(sInt);

ec();ft("Change first element to 7", "[7 14 23 42 101 201 666]");
sInt[0] = 7;
print(sInt);

ec();ft("Get second element", "14");
print(sInt[1]);

ec();ft("Block", "in");
{
    print("in");
}

ec();ft("Empty", "");
;

ec();ft("For range closed interval 11 to 14", "11,12,13,14,");
var xRange int;
for xRange = range 11@14 {
    print(xRange);
    print(",");
}

ec();ft("Continue on evens--print odds", "23,25,27,");
var xRange86 int;
for xRange86 = range 22@27 {
    if xRange86 % 2 == 0 continue;
    print(xRange86);
    print(",");
}
ec();ft("Break", "101,102,");
var xBreak int;
for xBreak = range 101@104 {
if xBreak == 103 {
break;
}
print(xBreak);
print(",");
}
ec();ft("Deep return", "203");
func deepReturn() int {
    var i int;
    for i = range 202@205 {
        if i == 203 return i;
    }
}
print(deepReturn());

ec();ft("3 part for statement", "10,12,14,");
for forX := 10; forX < 15; forX += 2 {
    print(forX);
    print(",");
}

ec();ft("For range key value", "0 abcd.1 xyz.2 hello.");
var key int;
var value string;
arS := ["abcd", "xyz", "hello"];
for key, value = range arS {
    print(key, value);print(".");
}

ec();ft("For loop without init", "In for");
var bFor bool;
for ; bFor != true; bFor = !bFor {
    print("In for");
}

ec();ft("If true print true", "true");
if true print("true");

ec();ft("If false do not print bad", "");
if false print("bad");

ec();ft("If false print else", "else");
if false ; else print("else");

ec();ft("If true do not print else", "");
if true ; else print("bad else");

ec();ft("Ternary true", "42");
print (true ? 42 : 5);

ec();ft("Ternary false", "good");
print (false ? "bad" : "good");


ec();ft("While countdown", "50.40.30.20.");
wh := 50;
while wh > 10 {
    print(wh);
    wh -= 10;
    print(".");
}

ec();ft("Repeat \"ab\" and doubling while len < 8", "ab.abab.");
wstr := "ab";
repeat {
    print(wstr);
    print(".");
    wstr += wstr;
} while len(wstr) < 8;

ec();ft("Slice middle of slice", "[4 5]");
ar := [1, 4, 5, 14, 23, 32];
s := ar[1:3];
print(s);

ec();ft("Slice first 2 closed interval", "[1 4]");
print(ar[@1]);

ec();ft("Slice last 3", "[14 23 32]");
print(ar[3:]);

func f() { print("in f"); }

ec();ft("Call function", "in f");
f();

ec();ft("Call function with 42, print", "42");
func g(iLocal int) { print(iLocal); }
g(42);

ec();ft("Call variadic", "7,13,101,");
func variadic(i ...int) {
    var x int;
    for x = range i {
        print(x);
        print(",");
    }
}
variadic(7, 13, 101);

ec();ft("Forward call", "forward");

func forward() {
    forwardCalled();
}

func forwardCalled() {
    print("forward");
}
forward();



ec();ft("Call returns", "42");
func returns42() int {
    return 42;
}
print(returns42());

ec();ft("Return exits", "good");
func exits() {
    print("good");
    return;
    print("bad");
}
exits();

ec();ft("Call recursive", "1 ,2 ,3 ,4 ,");
func countToFour(i int) {
    if i > 1 {
        countToFour(i - 1);
    }
    print(i, ",");
}
countToFour(4);

ec();ft("Function with map, slice, variadic", "foo 4210,11,12,13,14,false,false,true,");
func fLots(m [map]int, a [slice]int, vary ...bool) {
var s string;
var i int;
for s, i = range m {
print(s, i);
}
for i = range a {
print(i);
print(",");
}
var b bool;
for b = range vary {
print(b);
print(",");
}
}
var outerm [map]int;
outerm["foo"] = 42;
fLots(outerm, 10@14, false, false, true);

ec();ft("Deep function return", "");
func deep() {
    repeat {
        return;
        print("bad");
    } while false;
}

ec();ft("Guard fail", "fail");
func fguard() {
    guard false else {
        print("fail");
        return;
    }
    print("bad");
}
fguard();

ec();ft("Guard pass", "afterguard");
func fguard2() {
    guard true else {
    print("bad");
    return;
    }
print("afterguard");
}
fguard2();

ec();ft("Chain call", "true");
func call2nd() int {
    return 42;
}
func call1st() bool {
    return call2nd() < 45;
}
print(call1st());

ec();ft("Mutually recurse", "m1,1m2,2m1,4m2,5m1,10m2,11m1,22m2,23m1,46m2,47m1,94m2,95");
MLIMIT := 100;
func mrecurse1(x int) {
    print("m1,");
    print(x);
    x += 1;
    if x < MLIMIT {
        mrecurse2(x);
    }
}
func mrecurse2(i int) {
    print("m2,");
    print(i);
    i *= 2;
    if i < MLIMIT {
        mrecurse1(i);
    }
}
mrecurse1(1);
ec()
;ft("Return slice of strings","[aap noot mies]");
func returnSliceString() [slice]string {
ar := ["aap", "noot", "mies"];
return ar;
}
print(returnSliceString());

ec();ft("Match true", "matched");
match true {
when false:
    print("bad");
when true:
    print("matched");
}
ec();ft("Match default", "default");
match 5 {
when 2: print("2, bad");
when 1:
default: print("default");
}
ec();ft("Fallthrough", "start,fell through");
match true {
when true: print("start,");
fallthrough;
when false: print("fell through");
}
ec();ft("Fallthrough default", "match foo,fell through default");
match "foo" {
when "foo":
    print("match foo,");
    fallthrough;
default:
    print("fell through default");
}
ec();ft("Break out of default", "default only,");
match true {
default:
print("default only,");
break;
print("after break");
}
ec();ft("Continue with outer for", "in match,10in match,11in match,12in match,13in match,14");
var deepX int;
for deepX = range 10@14 {
match true {
when true:
print("in match,");
print(deepX);
continue;
}
print("bad");
}

ec();ft("Break with outer for", "in break match,10in break match,11in break match,12in break match,13in break match,14");
var deepX324 int;
for deepX324 = range 10@14 {
match true {
when true:
print("in break match,");
print(deepX324);
break;
print("bad");
}
}

ec();ft("Return from deep match in function", "201,203");
func deepR() int {
var x int;
for x = range 201@204 {
match x {
when 203:
return 203;
when 201:
print("201,");
}
}
}

print(deepR());
ec();ft("7, 3. + - * / %", "10 4 21 2 1");
A := 7;
B := 3;
print(A + B, A - B, A * B, A / B, A % B );
ec();ft("Eq, not eq, lt, gt", "false true false true");
print (A == B, A != B, A < B, A > B);
ec();ft("<= and >=", "true false true false");
print (5 <= 5, 6 <= 5, 5 >= 5, 4 >= 5);
SA := "bar";
SB := "foo";
ec();ft("bar foo < > ==", "barfoo true false false");
print (SA + SB, SA < SB, SA > SB, SA == SB);

ec();ft("&& ||", "true false true false");
print (true && true, true && false, true || false, false || false);
func bad() bool {print("bad"); return false;}
ec();ft("bad test", "false true");
print (false && bad(), true || bad());

ec();ft("Compound + - * % /", "<7><4><8><2><1>");

comp := 5;
comp += 2;
brak(comp);
comp -= 3;
brak(comp);
comp *= 2;
brak(comp);
comp %= 3;
brak(comp);
comp /= 2;
brak(comp);
ec();ft("Order of ops", "<9><7>");
brak(1+2*3);
brak(1+(2*3));
ec();ft("++ --", "<6><4>");
dub := 5;
dub++;
brak(dub);
dub--;
dub--;
brak(dub);
ec();ft("Negative int and decimal", "-5 -10.2");
negint := -5;
var negdec decimal;
negdec = -10.2;
print(negint, negdec);
ec();ft("print", "Hello, world.");
print("Hello, world.");
ec();ft("println", "End with lf.");
println("End with lf.");
ft("Printed lf", "");
ec();ft("printB", "111");
printB(7);
ec();ft("printH", "1e");
printH(30);
ec();ft("delete", "{foo:42}{}");
var intMap [map]int;
intMap["foo"] = 42;
print(intMap);
delete(intMap, "foo");
delete(intMap, "bar");
print(intMap);
ec();ft("len array", "3 7");
lenAr := [1, 22, 42];
print(len(lenAr), len(101@107));
ec();ft("map length", "<0><1><2>");
var boolMap [map]bool;
brak(len(boolMap));
boolMap["aap"] = true;
brak(len(boolMap));
boolMap["noot"] = true;
brak(len(boolMap));
ec();ft("string length", "4");
print(len("abcd"));
ec();ft("string Value", "42");
var strv string;
strv = stringValue(42);
print(strv);
DA := 1.1;
DB := 5.5;
ec();ft("decimal + - * /", "6.6 -4.4 6.05 0.2");
print(DA + DB, DA - DB, DA * DB, DA / DB);

ec();
/*ft("Slice Sort", "[1 4 32 45 101]");

toSort := [4, 45, 1, 101, 32];
sorted := sort(toSort);
print(sorted);

ec();
*/
ft("Global int in header", "3");
GLOB := 3;
func giih(ar [GLOB]bool) {
    print(len(ar));
}
var glob [GLOB] bool;
giih(glob);

ec();ft("Array copies in call", "23");
func arFunc(ar [1]int) {
    ar[0] = 42;
}
var arF[1]int;
arF[0] = 23;
arFunc(arF);
print(arF[0]);


ec();ft("Slice shares in call", "[201 101]");
func slFunc(s [slice]int) {
    s[0] = 201;
}
var slf [slice]int;
slf = [23, 101];
slFunc(slf);
print(slf);
ec();

ft("Map shares in call", "{aap:101}");
func mFunc(m [map]int) {
    m["aap"] = 101;
}
mapShare := { "aap": 42};
mFunc(mapShare);
print(mapShare);

ec();

ft("Tuple copies in call", "(42 7)");
func mTup(t (int, int)) {
    t[0] = 301;
}
tupShare := (42, 7);
mTup(tupShare);
print(tupShare);
ec();

ft("Tuple", "true 42 1.5 (42 true str 1.5)");
tup := (42, true, "str", 1.5);

print(tup[1], tup[0], tup[3], tup);
ec();
ft("Set tuple", "23 false");
tup[0] = 23;
tup[1] = false;
print(tup[0], tup[1]);
ec();
ft("Compound add array, tuple, map", "[30 23] 4.5 {aap:201}");
caAr := [10, 23];
caAr[0] += 20;
caTu := (100, 1.5);
caTu[1] += 3.0;
caMa := {"aap": 101};
caMa["aap"] += 100;
print(caAr, caTu[1], caMa);
ec();
ft("Postfix minus array tuple, map", "49 100 22");
pfA := [50];
pfT := (101, "boo");
pfM := {"aaa": 23};
pfA[0]--;
pfT[0]--;
pfM["aaa"]--;
print(pfA[0], pfT[0], pfM["aaa"]);
ec();
ft("Compound equals", "true false");
ceAr1 := [1, 5, 23];
ceAr2 := [1, 5, 23];
ceAr3 := [1, 7, 23];
print(ceAr1 == ceAr2, ceAr2 == ceAr3);
ec();
ft("Map equals", "true false false");
meMap1 := {"aap": 5};
meMap2 := {"aap": 5};
meMap3 := {"noot": 5};
meMap4 := {"aap": 32};
print(meMap1 == meMap2, meMap1 == meMap3, meMap1 == meMap4);
ec();

ft("Map returns zero value with no key", "0, false");
var mrz [map]int;
print(mrz["a"]);
print(",", key(mrz, "a"));

ec();


ft("Tuple equals", "true false");
teTup := (5, "aap", false);
teTup2 := (5, "aap", false);
teTup3 := (23, "aap", false);
print(teTup == teTup2, teTup == teTup3);
ec();
ft("Global ar", "[1 5]");
gar := [1, 5];
func garf() {
    gar = [10, 12];
}
print(gar);
ec();
ft("Short declaration copies integer", "5 5,10 5");
sdci1 := 5;
sdci2 := sdci1;
print(sdci1, sdci2);
print(",");
sdci1 = 10;
print(sdci1, sdci2);
ec();
/*
ft("Slicing shares", "");
ssAr1 := [1, 10, 101, 202];
ssAr2 := ssAr1[1@2];
ssAr2[0] = 777;
print(ssAr1);
print(",");
print(ssAr2);
ec();
*/
