
func conc(d string, v string) string {
    return d + "!" + v + "#";
}

//func ft(d string, v string) {
//print(conc(d, v));
//}

ft("Create int", "0");
var x int;
print(x);

ft("Print", "a \\ slash");
print("a \\ slash");

ft("Print empty array", "[]");
var empty [0]int;
print(empty);

ft("Print singleton array", "[23]");
print([23]);

ft("Print two in array", "[101 777]");
print([101, 777]);

ft("Print single element object", "{foo:42}");
print({"foo": 42});

ft("Create and set to 10", "10");
var x2 int;
x2 = 10;
print(x2);

ft("Create bool", "false");
var b bool;
print(b);

ft("Create string", "");
var str string;
print(str);

ft("Set string", "value");
var str2 string;
str2 = "value";
print(str2);

ft("Short declaration", "true");
shortBool := true;
print(shortBool);

ft("Create map", "{answer:true} true false");
var newMap [map]bool;
newMap["answer"] = true;
print(newMap, key(newMap, "answer"), key(newMap, "not"));

ft("Create slice", "[777]");
var newSlice [slice]int;
newSlice[0] = 777;
print(newSlice);

ft("Create array", "aap");
var newArray [3]string;
newArray[1] = "aap";
print(newArray[1]);

ft("Create array of string", "[alpha bravo charlie]");
var arStr [3]string;
arStr[0] = "alpha";
arStr[1] = "bravo";
arStr[2] = "charlie";
print(arStr);

ft("Create deep nesting", "[[42 101]]");
var cdn [slice][slice]int;
var cdns [slice]int;
cdns[0] = 42;
cdns[1] = 101;
cdn[0] = cdns;
print(cdn);

ft("Deep nesting and length", "[(0 {} [[0 0 0 0 42]])] 1 5 [(42 {key:true} [12 101]) (101 {aap:false} [202])]");
var cx [slice](int, [map]bool, [slice][5]int);
//xam("cx");
cx2 := [(42, {"key": true}, [12, 101])];
cx2[1] = (101, {"aap": false}, [202]);
cx[0][2][0][4] = 42;
print(cx, len(cx), len(cx[0][2][0]), "");
print(cx2);

ft("Nested types, declared", "[true] [[true] [] []]");
var cdn42 [3][slice]bool;
var cdns42 [slice]bool;
cdns42[0] = true;
cdn42[0] = cdns42;
print(cdns42, cdn42);

ft("Nested types, declared deep array", "[[[0 0 0 0] [0 0 42 0] [0 0 0 0]] [[0 0 0 0] [0 0 0 0] [0 0 0 0]]]");
var ntdda [2][3][4]int;
ntdda[0][1][2] = 42;
print(ntdda);

ft("Short declaration slice", "[10 23 42 101] [10 23 42 101]");
sda := [10, 23, 42, 101];
print(sda, "");
var sds [slice]int;
sds = sda;
print(sds);

ft("Short declaration nested slice", "[[2 1] [21 23 101]][[2 1] [21 23 101]]");
sdns := [[2, 1], [21, 23, 101]];
print(sdns);
var sdns2 [slice][slice]int;
sdns2 = sdns;
print(sdns2);

ft("Assign smaller slice to slice plus length", "[202 302] 2");
assts := [24, 30, 101];
assts = [202, 302];
print(assts, len(assts));

ft("Assign larger slice to slice plus length", "[202 302 502] 3");
alsts := [24, 30];
alsts = [202, 302, 502];
print(alsts, len(alsts));

ft("Print open interval 1 to 5", "[1 2 3 4]");
print(1:5);

ft("Print closed interval 11 through 13", "[11 12 13]");
print(11@13);

ft("Create array of ints", "[10 14 23 42 101 201]");
aInt := [10, 14, 23, 42, 101, 201];
print(aInt);
ft("Create literal of pointer and nil", "[P N]");
ar := [*(42, true), nil];
print(ar);
ft("Convert array to slice", "[42 101] [42 101]");
var ar[2]int;
ar[0] = 42;
ar[1] = 101;
var s[slice]int;
s = ar[:];
print(ar, s);
ft("Copy to slice of ints", "[10 14 23 42 101 201]");
aInt := [10, 14, 23, 42, 101, 201];
sInt := aInt[:];
print(sInt);

ft("Add 666 to slice of ints", "[10 14 23 42 101 201 666]");
aInt := [10, 14, 23, 42, 101, 201];
sInt := aInt[:];
sInt[len(sInt)] = 666;
print(sInt);

ft("Change first element to 7", "[7 14 23 42 101 201 666]");
aInt := [10, 14, 23, 42, 101, 201];
sInt := aInt[:];
sInt[len(sInt)] = 666;
sInt[0] = 7;
print(sInt);

ft("Get second element", "14");
aInt := [10, 14, 23, 42, 101, 201];
sInt := aInt[:];
print(sInt[1]);

ft("Block", "in");
{
    print("in");
}

ft("Empty", "");
;

ft("For range closed interval 11 to 14", "11,12,13,14,");
var xRange int;
for xRange = range 11@14 {
    print(xRange);
    print(",");
}

ft("Continue on evens--print odds", "23,25,27,");
var xRange86 int;
for xRange86 = range 22@27 {
    if xRange86 % 2 == 0 continue;
    print(xRange86);
    print(",");
}
ft("Break", "101,102,");
var xBreak int;
for xBreak = range 101@104 {
if xBreak == 103 {
break;
}
print(xBreak);
print(",");
}
ft("Deep return", "203");
func deepReturn() int {
    var i int;
    for i = range 202@205 {
        if i == 203 return i;
    }
}
print(deepReturn());

ft("3 part for statement", "10,12,14,");
for forX := 10; forX < 15; forX += 2 {
    print(forX);
    print(",");
}

ft("For range key value", "0 abcd.1 xyz.2 hello.");
var key int;
var value string;
arS := ["abcd", "xyz", "hello"];
for key, value = range arS {
    print(key, value);print(".");
}

ft("For loop without init", "In for");
var bFor bool;
for ; bFor != true; bFor = !bFor {
    print("In for");
}

ft("If true print true", "true");
if true print("true");

ft("If false do not print bad", "");
if false print("bad");

ft("If false print else", "else");
if false ; else print("else");

ft("If true do not print else", "");
if true ; else print("bad else");

ft("Ternary true", "42");
print (true ? 42 : 5);

ft("Ternary false", "good");
print (false ? "bad" : "good");


ft("While countdown", "50.40.30.20.");
wh := 50;
while wh > 10 {
    print(wh);
    wh -= 10;
    print(".");
}

ft("Repeat \"ab\" and doubling while len < 8", "ab.abab.");
wstr := "ab";
repeat {
    print(wstr);
    print(".");
    wstr += wstr;
} while len(wstr) < 8;

ft("Slice middle of slice", "[4 5]");
ar := [1, 4, 5, 14, 23, 32];
s := ar[1:3];
print(s);

ft("Slice first 2 closed interval", "[1 4]");
ar := [1, 4, 5, 14, 23, 32];
s := ar[1:3];
print(ar[@1]);

ft("Slice last 3", "[14 23 32]");
ar := [1, 4, 5, 14, 23, 32];
s := ar[1:3];
print(ar[3:]);

ft("Double slice", "[4 5]");
ar := [1, 4, 5, 14, 23, 32];
s := ar[1:3];
print(ar[@4][1@2]);


ft("Call function", "in f");
func f() { print("in f"); }

f();

ft("Call function with 42, print", "42");
func g(iLocal int) { print(iLocal); }
g(42);

ft("Call variadic", "7,13,101,");
func variadic(i ...int) {
    var x int;
    for x = range i {
        print(x);
        print(",");
    }
}
variadic(7, 13, 101);

ft("Forward call", "forward");

func forward() {
    forwardCalled();
}

func forwardCalled() {
    print("forward");
}
forward();



ft("Call returns", "42");
func returns42() int {
    return 42;
}
print(returns42());

ft("Return exits", "good");
func exits() {
    print("good");
    return;
    print("bad");
}
exits();

ft("Call recursive", "1 ,2 ,3 ,4 ,");
func countToFour(i int) {
    if i > 1 {
        countToFour(i - 1);
    }
    print(i, ",");
}
countToFour(4);

ft("Function with map, slice, variadic", "foo 4210,11,12,13,14,false,false,true,");
func fLots(m [map]int, a [slice]int, vary ...bool) {
var s string;
var i int;
for s, i = range m {
print(s, i);
}
for i = range a {
print(i);
print(",");
}
var b bool;
for b = range vary {
print(b);
print(",");
}
}
var outerm [map]int;
outerm["foo"] = 42;
fLots(outerm, 10@14, false, false, true);

ft("Deep function return", "");
func deep() {
    repeat {
        return;
        print("bad");
    } while false;
}

ft("Guard fail", "fail");
func fguard() {
    guard false else {
        print("fail");
        return;
    }
    print("bad");
}
fguard();

ft("Guard pass", "afterguard");
func fguard2() {
    guard true else {
    print("bad");
    return;
    }
print("afterguard");
}
fguard2();

ft("Chain call", "true");
func call2nd() int {
    return 42;
}
func call1st() bool {
    return call2nd() < 45;
}
print(call1st());

ft("Mutually recurse", "m1,1m2,2m1,4m2,5m1,10m2,11m1,22m2,23m1,46m2,47m1,94m2,95");
MLIMIT := 100;
func mrecurse1(x int) {
    print("m1,");
    print(x);
    x += 1;
    if x < MLIMIT {
        mrecurse2(x);
    }
}
func mrecurse2(i int) {
    print("m2,");
    print(i);
    i *= 2;
    if i < MLIMIT {
        mrecurse1(i);
    }
}
mrecurse1(1);
ft("Return slice of strings","[aap noot mies]");
func returnSliceString() [slice]string {
ar := ["aap", "noot", "mies"];
return ar;
}
print(returnSliceString());

ft("Match true", "matched");
match true {
when false:
    print("bad");
when true:
    print("matched");
}
ft("Match default", "default");
match 5 {
when 2: print("2, bad");
when 1:
default: print("default");
}
ft("Fallthrough", "start,fell through");
match true {
when true: print("start,");
fallthrough;
when false: print("fell through");
}
ft("Fallthrough default", "match foo,fell through default");
match "foo" {
when "foo":
    print("match foo,");
    fallthrough;
default:
    print("fell through default");
}
ft("Break out of default", "default only,");
match true {
default:
print("default only,");
break;
print("after break");
}
ft("Continue with outer for", "in match,10in match,11in match,12in match,13in match,14");
var deepX int;
for deepX = range 10@14 {
match true {
when true:
print("in match,");
print(deepX);
continue;
}
print("bad");
}

ft("Break with outer for", "in break match,10in break match,11in break match,12in break match,13in break match,14");
var deepX324 int;
for deepX324 = range 10@14 {
match true {
when true:
print("in break match,");
print(deepX324);
break;
print("bad");
}
}

ft("Return from deep match in function", "201,203");
func deepR() int {
var x int;
for x = range 201@204 {
match x {
when 203:
return 203;
when 201:
print("201,");
}
}
}

print(deepR());
ft("7, 3. + - * / %", "10 4 21 2 1");
A := 7;
B := 3;
print(A + B, A - B, A * B, A / B, A % B );

ft("Eq, not eq, lt, gt", "false true false true");
A := 7;
B := 3;
print (A == B, A != B, A < B, A > B);

ft("Order", "false");
print(true && 10 < 2 + 1 );

ft("<= and >=", "true false true false");
print (5 <= 5, 6 <= 5, 5 >= 5, 4 >= 5);

ft("bar foo < > ==", "barfoo true false false");
SA := "bar";
SB := "foo";
print (SA + SB, SA < SB, SA > SB, SA == SB);

ft("&& ||", "true false true false");
print (true && true, true && false, true || false, false || false);
func bad() bool {print("bad"); return false;}
ft("bad test", "false true");
print (false && bad(), true || bad());

ft("Compound + - * % /", "7 4 8 2 1");

comp := 5;
comp += 2;
print(comp, "");
comp -= 3;
print(comp, "");
comp *= 2;
print(comp, "");
comp %= 3;
print(comp, "");
comp /= 2;
print(comp);
ft("Order of ops", "9 7");
print(1+2*3, "");
print(1+(2*3));
ft("++ --", "6 4");
dub := 5;
dub++;
print(dub, "");
dub--;
dub--;
print(dub);
ft("Unary negative int and decimal", "-5 -10.2");
negint := -5;
var negdec decimal;
negdec = -10.2;
print(negint, negdec);
ft("Unary plus", "202");
print(+202);
ft("Unary boolean negate", "false");
print(!true);
ft("print", "Hello, world.");
print("Hello, world.");
ft("println", "End with lf.
");
println("End with lf.");

ft("delete", "{aap:101 foo:42}true false{aap:101}");
var intMap [map]int;
intMap["foo"] = 42;
intMap["aap"] = 101;
print(intMap);
print(delete(intMap, "foo"), "");
print(delete(intMap, "bar"));
print(intMap);

ft("len array", "3 7");
lenAr := [1, 22, 42];
print(len(lenAr), len(101@107));

ft("map length", "0 1 2");
var boolMap [map]bool;
print(len(boolMap), "");
boolMap["aap"] = true;
print(len(boolMap), "");
boolMap["noot"] = true;
print(len(boolMap));

ft("string length", "4");
print(len("abcd"));
ft("string Value", "42");
var strv string;
strv = stringValue(42);
print(strv);

ft("decimal + - * /", "6.6 -4.4 6.05 0.2");
DA := 1.1;
DB := 5.5;
print(DA + DB, DA - DB, DA * DB, DA / DB);

ft("Global int in header", "3");
GLOB := 3;
func giih(ar [GLOB]bool) {
    print(len(ar));
}
var glob [GLOB] bool;
giih(glob);

ft("Array copies in call", "23");
func arFunc(ar [1]int) {
    ar[0] = 42;
}
var arF[1]int;
arF[0] = 23;
arFunc(arF);
print(arF[0]);


ft("Slice shares in call", "[201 101]");
func slFunc(s [slice]int) {
    s[0] = 201;
}
var slf [slice]int;
slf = [23, 101];
slFunc(slf);
print(slf);


ft("Map shares in call", "{aap:101}");
func mFunc(m [map]int) {
    m["aap"] = 101;
}
mapShare := { "aap": 42};
mFunc(mapShare);
print(mapShare);


ft("Tuple", "(0 false )");
var tup23 (int, bool, string);
print(tup23);

ft("Tuple assignments", "([3 5] [aap noot])");
var tup2 ([slice]int, [slice]string);
tup2[0] = [3, 5];
tup2[1] = ["aap", "noot"];
print(tup2);


ft("Tuple short declaration", "true 42 1.5 (42 true str 1.5)");
tup := (42, true, "str", 1.5);

print(tup[1], tup[0], tup[3], tup);

ft("Set tuple", "23 false");
tup := (42, true, "str", 1.5);
tup[0] = 23;
tup[1] = false;
print(tup[0], tup[1]);

ft("Compound add array, tuple, map", "[30 23] 4.5 {aap:201}");
caAr := [10, 23];
caAr[0] += 20;
caTu := (100, 1.5);
caTu[1] += 3.0;
caMa := {"aap": 101};
caMa["aap"] += 100;
print(caAr, caTu[1], caMa);

ft("Postfix minus array tuple, map", "49 100 22");
pfA := [50];
pfT := (101, "boo");
pfM := {"aaa": 23};
pfA[0]--;
pfT[0]--;
pfM["aaa"]--;
print(pfA[0], pfT[0], pfM["aaa"]);

ft("Compound equals", "true false");
ceAr1 := [1, 5, 23];
ceAr2 := [1, 5, 23];
ceAr3 := [1, 7, 23];
print(ceAr1 == ceAr2, ceAr2 == ceAr3);

ft("Map equals", "true false false");
meMap1 := {"aap": 5};
meMap2 := {"aap": 5};
meMap3 := {"noot": 5};
meMap4 := {"aap": 32};
print(meMap1 == meMap2, meMap1 == meMap3, meMap1 == meMap4);


ft("Map returns zero value with no key", "0, false");
var mrz [map]int;
print(mrz["a"]);
print(",", key(mrz, "a"));

ft("Tuple equals", "true false");
teTup := (5, "aap", false);
teTup2 := (5, "aap", false);
teTup3 := (23, "aap", false);
print(teTup == teTup2, teTup == teTup3);

ft("Global ar", "[1 5]");
gar := [1, 5];
func garf() {
    gar = [10, 12];
}
print(gar);

ft("Short declaration copies integer", "5 5,10 5");
sdci1 := 5;
sdci2 := sdci1;
print(sdci1, sdci2);
print(",");
sdci1 = 10;
print(sdci1, sdci2);


ft("Slicing shares", "[1 777 101 202],[777 101]");
ssAr1 := [1, 10, 101, 202];
ssAr2 := ssAr1[1@2];
ssAr2[0] = 777;
print(ssAr1);
print(",");
print(ssAr2);

ft("Slice of arrays", "[[0 42] [101 0]] [[0 42] [0 42]] [[202 42] [202 42]]");
var soa [slice][2]int;

soa[0][1] = 42;
soa[1][0] = 101;
print(soa, "");
soa[1] = soa[0];
print(soa, "");
soa[0][0] = 202;
print(soa);

ft("Multi-dimensional array of int", "[[0 0 0] [0 0 42]]");
var mda [2][3]int;
mda[1][2] = 42;
print(mda);


ft("Multi-dimensional tuple", "([0 0 42 0 0] (true 101))");
var mdt ([5]int, (bool, int));
mdt[0][2] = 42;
mdt[1][1] = 101;
mdt[1][0] = true;
print(mdt);


ft("Multi-dimensional tuple set compound type", "([0 0 42 0 0] (true 202))");
var mdt ([5]int, (bool, int));
mdt[0][2] = 42;
mdt[1][1] = 101;
mdt[1][0] = true;
var mdt2 ([5]int, (bool, int));
mdt[1] = (true, 202);
print(mdt);


ft("Deeply nested type", "[(false 0 {}) (false 0 {})][(false 0 {}) (false 0 {aap:(42 noot)})]");
var dnt [2](bool, int, [map](int, string));
print(dnt);
dnt[1][2]["aap"] = (42, "noot");
print(dnt);

ft("Declared pointer","N true *(24 N) N N true");
var two *(int, self);
print(two, two == nil, "");
two = *(24, nil);
print(two, "");
print(two[1], "");
two = nil;
print(two, two == nil);

ft("Pointer in tuple", "(0 N) (0 P) *(true N) ");
var tup (int, *(bool, self));
print(tup, "");
tup[1] = *(true, nil);
print(tup, "");
print(tup[1], "");

ft("Nested tuple short", "(4 (10 P))(10 P)*(12 N)");
x := (4, (10, *(12, nil)));
print(x);
print(x[1]);
print(x[1][1]);

ft("Binary search tree", "1 2 3 5 7 10 ");
var i int;
bst := *(nil, 7, nil);
cur := bst;
for i = range [1, 5, 10, 2, 3] {
    cur = bst;
    loop {
        if i < cur[1] {
            if cur[0] == nil {
                cur[0] = *(nil, i, nil);
                break;
            } else {
                cur = cur[0];
                continue;
            }
        } else if i > cur[1] {
            if cur[2] == nil {
                cur[2] = *(nil, i, nil);
                break;
            } else {
                cur = cur[2];
                continue;
            }
        } else {
            break;
        }
    }
}

func dfs(node  *(self, int, self)) {
    if node == nil {
        return;
    }
        dfs(node[0]);
        print(node[1], "");
        dfs(node[2]);
}
dfs(bst);

ft("Linked list", "5 8 23 ");
var LL *(int, self);
LL = *(5, nil);
base := LL;

LL[1] = *(8, nil);

LL = LL[1];
LL[1] = *(23, nil);
func pll(node *(int, self)) {
    if node == nil {
        return;
    }
    print(node[0], "");
    pll(node[1]);
}
pll(base);


/*
ft("Doubly linked list", "(P 7 P)(E 5 P)(E 5 P)");
var dll *(self, int, self);
dll = *(nil, 5, nil);
base7 := dll;
dll[2] = *(dll, 7, nil);
dll = dll[2];
dll[2] = *(dll, 1, nil);
dll = dll[2];
print(base7[2]);
print(base7[2][0]);
print(base7[2][2][0][0]);
/*
ft("Nested pointer types, depth and flat", "(aap E P)(aap N (noot N N))(42 P E)(42 (101 N N) N)");
npt := ("aap", nil, ("noot", nil, nil));
print(npt);
print(depthString(npt));
npt2 := (42, (101, nil, nil), nil);
print(npt2);
print(depthString(npt2));

*/
