ft("Literal zero");
0;
assert(0, 0);

ft("Literals");
42;
assert(42, 42);
101;
1010;





//Create all with defaults





ft("Create int");
var x int;
assert(x, x);
assert(x, 0);
ft("Create 2 int");
var x int;
var y int;
assert(x, 0);
assert(y, 0);
assert(x, y);



ft("Xtra--create 2 int short");
var x, y int;
assert(x, 0);
assert(y, 0);


ft("Create and state");
var x int;
assert(x, 0);

x;
assert(x, 0);

ft("Set x to 0");
var x int;
x = 0;
assert(x, 0);

ft("Set to x to 42");
var x int;
x = 42;
assert(x, 42);
assert(x, x);

ft("Set x to itself");
var x int;
x = x;
assert(x, 0);
assert(x, x);

ft("Create and set 2 ints");
var x int;
var y int;
y = x;

assert(x, 0);
assert(y, 0);


ft("Create and set 3 ints");
var x int;
var y int;
var z int;
y = x;
z = y;
assert(x, 0);
assert(y, 0);
assert(z, 0);


ft("Create and set ints to each other");
var x int;
var y int;
x = y;
y = x;
assert(x, 0);
assert(y, 0);



ft("Create 3 ints");
var x int;
var y int;
var z int;
x = y;
y = x;
x = z;
z = x;
y = z;
z = y;
assert(x, 0);
assert(y, 0);
assert(z, 0);


ft("Multi set");
var x int;
var y int;
x, y = 11, 42;
assert(x, 11);
assert(42, y);


ft("Boolean");
false;
true;
assert(false, false);
assert(true, true);

ft("String");
"";
"str";
assert("str", "str");
"a";


ft("Boolean and String literals");
true;
false;
"str";
"";

ft("Create bool");
var b bool;
assert(b, false);


ft("Create string");
var str string;
assert(str, "");

//Create collections

ft("Create array");
var x [1]int;

ft("Add len");
var x[5]int;
assert(len(x), 5);

ft("Create array 2");
var x [2]int;
var y [7]int;

ft("Variable array bounds");
var bound int;
bound = 2;
var y [bound]int;
assert(bound, len(y));
bound = 3;
var z [bound]int;
assert(bound, len(z));





ft("Create comp array");
var x[1][1]int;
var y[7][1]int;
assert(len(y), 7);
var z[1][7]int;

ft("Array assign");
var x[7]int;
var y[7]int;
x = y;
y = x;
assert(len(x), 7);
assert(len(y), 7);

ft("Array index");
var x[3]int;
x[2];
assert(x[2], 0);
x[0];
assert(x[0], 0);

ft("Array index assign");
var x[3]int;
x[0] = 0;

ft("Create array and set");
var na [2]int;
na[0] = 42;
na[1] = 101;
assert(na[0], 42);
assert(na[1], 101);
//slice

ft("Create slice");
var x []int;
assert(len(x), 0);

ft("Slice 2");
var x []int;
var y []bool;
assert(len(x), 0);
assert(len(y), 0);

ft("Slice composite");
var x [][]int;
var y [][][]bool;

ft("Slice assign");
var x, y []int;
x = y;
y = x;
assert(x, y);

ft("Slice extend");
var x []int;
assert(len(x), 0);
x[0] = 10;
assert(len(x), 1);

x[1] = 42;
assert(len(x), 2);

ft("Slice index");
var x []int;
x[0] = 20;
assert(x[0], 20);
assert(len(x), 1);

//map

ft("Create map");
var x [map]int;

ft("Map 2");
var x [map]bool;

ft("Comp map");
var x [map][map]int;
var y [map][map][map]bool;

ft("Map assign");
var x, y [map]int;
x = y;
y = x;
assert(x, y);
var i[map][map]bool;
var j[map][map]bool;
i = j;
j= i;
assert(i, j);


ft("Map index");
var x [map]int;
assert(x["k"], 0);


//tuple

ft("Tuple");
var t (int, int);
assert(len(t), 2);

ft("Tuple 2");
var x (int, int, int);
var y (int, bool);

ft("Tuple composite");
var x (int, (int, bool));

ft("Tuple assign");
var x, y (int, int);
x = y;
y = x;

ft("Tuple index (both syntax)");
var x (int, int);
x[0];
assert(x[0], 0);
x[0] = 0;
assert(x[0], 0);
assert(x.1, 0);

var y ((int, int), int);
y[0][1] = 12;
y[1] = 23;
assert(y[0][1], 12);
assert(y[1], 23);
ft("Tuple destructure");
var x, y int;
(x, y) = (23, 42);
assert(x, 23);
assert(y, 42);

ft("Tuple destructure 2");
var x int;
var y bool;
(x, y) = (101, true);
assert(x, 101);
assert(y, true);



//Pointer

ft("Pointer");
var p *(int);

ft("Pointer 2");
var x *(int, int);
var y *(int, bool);
var z *(bool);

ft("Comp pointer");
var p *(*(int), bool);
var p2 *(*(int));

ft("Pointer assign");
var x *(int);
var y *(int);
x = y;
y = x;

ft("Pointer index (literal needed)");
var p *(int, int);
p = *(1, 4);
p[0];
assert(p[0], 1);
assert(p[1], 4);


// Struct

ft("Struct");
var s {a: int, b: bool};

ft("Struct composite");
var s {a: {z: int}};

ft("Struct assign");
var s1 {a: int, b: bool};
var s2 {a: int, b: bool};
s1 = s2;
s2 = s1;

ft("Xtra--Struct assign");
var s1 {a: int, b: bool};
var s2 {b: bool, a: int};
s1 = s2;
s2 = s1;

ft("Struct index get");
var s {a: int, b: bool};
assert(s["a"], 0);

ft("Struct index assign");
var s {a: int, b: bool};
s["a"] = 42;
assert(s["a"], 42);





// Compound literals


// Array literal
ft("Array literal");
[0];

ft("Array literal 2");
[true];
["str"];
[1, 2];
[1, 5, 10];
assert([1, 42][1], 42);

ft("Array literal comp");
assert([[0, 10], [2, 5]][0][1], 10);


// Slice literal
ft("Slice literal");
...[];

ft("Slice literal 2");
...[true];
...["str"];
...[1, 2];
...[1, 5, 10];

ft("Slice literal comp");
...[...[0]];


// Map literal
ft("Map literal");
{}

ft("Map literal 2");
{"a": "b", "c": "d", "e": "val"};
{"key": 42};

ft("Map compos");
{"out": {"in": 5}};

// Tuple literal

ft("Tuple");
();

ft("Tuple 2");
(1, 5);

ft("Tuple composite");
((1, true, false), 5);

// Pointer literal

ft("Pointer");
*();

ft("Pointer 2");
*(3);
*(false, true);
*(10, 11, 102);

ft("Pointer composite");
*(*(true, false), 1, 5, "abc");

// Struct literal

ft("Struct");
*{a: 42, b: true};
ft("Struct 2");
*{a: true, b: 42, c: "str"};
ft("Struct composite");
*{key: *{a: true, b: 101}, key2: *{z: "zee"}};

//print(x);

// Mixes

ft("Arrays null");
[*(), *(), *()];
[...[], ...[]];
[{}, {}];

ft("Array mix null/non");
[*(42), *(101), *()];
[...[], ...[101, 4]];
[{"bcd": false}, {}, {"a": true}];


ft("Slice null");
...[*(), *()];
...[...[], ...[]];
...[{}, {}];


ft("Slice mix null/non");
...[*(101), *(), *(202)];
...[...[] , ...[true, false]];
...[{}, {"a": 42}];

ft("Map null");
{a: *(), b: *()};
{a: ...[], b: ...[]};
{a: {}, b: {}};

ft("Map mix");
{a: *(42), b: *()};

ft("Composite all");
(1, 5, 101, [1, 5], ...[10, 12], {"key": 42}, *(12, 20));

ft("Tuple null/mix");
(*(), *());
(...[], ...[5]);

ft("Pointer null/mix");
*(*(), *());
*({}, {a: 42});



// Collection literal assignment

ft("Array");
var x [1]int;
x = [0];
var y [2]int;
y = [0, 0];
var z [3]bool;
z = [false, true, false];
assert(z[1], true);
//assert(len(z), 3);
var comp [2][3]int;
comp = [[1, 2, 5], [10, 12, 13]];
ft("Slice");
var x[]int;
x = ...[0];
x = ...[12, 42];
assert(len(x), 2);
assert(x[0], 12);
assert(x[1], 42);

at(sequal(x, ...[12, 42]));

var y[]bool;
y = ...[false, true, false];
var z[]string;
z = ...["abc", "def"];
var z2[][]int;
z2 = ...[...[1, 2], ...[10, 11]];

ft("Map");
var x[map]int;
x = {a: 42};
var y[map][map]bool;
y = {a: {b: true}, b: {z: false, zz: true}};

ft("Tuple");
var x (int, bool, string);
x = (42, true, "str");
var y ((int, bool), string);
y = ((23, false), "ing");

ft("Pointer");
var x *(int);
x = *(101);
var y *(*(int, bool), string);
y = *(*(42, true), "str");

ft("Structure");
var x {x: int, y: int, c: string};
x = *{x: 10, y: 20, c: "green"};

// Short declaration

ft("Short");
x := 0;
x = 0;
assert(x, 0);

ft("Short declaration");
var x int;
y := 4;
x = y;
assert(x, 4);
assert(y, 4);

ft("Short 3");
var x int;
y := x;
assert(y, 0);
y = 2;
assert(y, 2);
assert(x, 0);

ft("Short list");
x, y := 10, 105;
assert(x, 10);
assert(y, 105);

ft("Short destructure");
(x, y) := (10, true);
assert(x, 10);
assert(y, true);












// Stress

ft("Nulls");
var x (*(int), *(int), *(int));
x = (*(), *(42), *());
assert(len(x), 3);
assert(x[0], *());
assert(x[1][0], 42);
assert(x[2], *());


ft("Null deep structure");
var x, y *(*(int), *(*(bool)));
x = *(*(42), *());
y = *(*(), *(*()));


ft("Self");
var x, y, z *(int, self);
x = *(42, *());
y = *(11, *(12, *()));
z = *(23, *(42, *(101, *())));
z[1][1][1] = *(202, *());
//print(z, z[1], z[1][1]);

//sequal

ft("API: sequal");
at(sequal(...[1, 5], ...[1, 5]));
at(!sequal(...[5], ...[1]));
at(!sequal(...[5], ...[5, 5]));



//Slicing

ft("Slicing");
var x[3]int;
x[0:2];

ft("Slicing 2");
var x[3]int;
x[0:0];
x[:3];
x[1:];
x[:];

ft("At slicing");
var x[3]int;
x[0@2];
x[@2];

ft("Slice a slice");
var x[]int;
x[0] = 2;
x[1] = 23;
x[2] = 101;
x[0@2];
x[:];

ft("String slice");
"abc"[0:2];
"a"[0:0];

ft("Repeat slicing");
"abcd"[1:4][0:1];














// Expressions

ft("plus");
assert(0 + 0, 0);

ft("Plus 2");
assert(1 + 2 + 3, 6);
assert("con" + "cat", "concat");
assert("ab" + "cdef", "abcdef");

ft("Equal");
at(0 == 0);

ft("Equal 2");
assert(0 == 1, false);
assert(true == false, false);
at(true == true);
assert("abc" == "abcdef", false);

ft("LT");
0 < 10;
assert(0 < 10, true);
assert(10 < 0, false);
assert("ab" < "def", true);

ft("&&");
true && true;
true && false;
false && 0 + true;

ft("||");
true || false;

//Unary

ft("Unary");
+0;
-0;
assert(!true, false);
assert(!false, true);
assert(+42, 42);
assert(-12, 0 - 12);


ft("Binary int->int");
assert(2 + 3, 5); //5
assert(2 - 3, 0 - 1); //-1
assert(2 * 3, 6); //6
assert(2 / 3, 0); //0
assert(2 % 3, 2); //2

ft("Binary comp");
true == true;
assert(2 != 3, true);
assert(2 > 3, false);
assert(2 >= 3, false);
assert(2 <= 3, true);

ft("Range expr");
at(sequal(0:1, ...[0]));
//0:0;


ft("Range 2");
at(sequal(0:5, ...[0, 1, 2, 3, 4]));
at(sequal(1@3, ...[1, 2, 3]));

ft("Range equals");
var x []int;
x = 2:10;
x = 10@20;

ft("Paren");
(0);

ft("Paren comp");
((0));

ft("Conditional");
assert(true ? 2 : 1, 2);

ft("Conditional 2");
assert(false ? 1 + 2 : true, true);









ft("Int copies by value");
var x int;
var y int;
x = 23;
y = x;
y = 42;
assert(x, 23);
assert(y, 42);

ft("Create and tuple destructure");
var x int;
var y bool;
(x, y) = (42, true);
assert(x, 42);
assert(y, true);


ft("Multi swap");
x, y := 42, 101;
x, y = y, x;
assert(x, 101);
assert(y, 42);

//Constant

ft("Constant");
const X = 12;

assert(X, 12);

ft("Constant collection");
const AR = [[1, 5], [10, 21]];
var a[2]int;
a = AR[0];
a[0] = 42;

//Blank

ft("Blank");
var _ int;
var _ bool;
var _ (int, bool);
(_, j) := (42, 101);
assert(j, 101);



//Decimal

ft("Literal");
0.0;

ft("Create decimal");
var d decimal;

ft("Create decimal value");
var d decimal;
assert(d, 0.0);

ft("Print literal");
assert(sprint(0.0), "0");

ft("Decimal expressions");
0.5 + 1.5;
1.0 * 10.5;

ft("Decimal expression values");
assert(1.5 + 3.0, 4.5);
assert(1.1 * 3.0, 3.3);
assert(1.75 - 0.25, 1.5);



//Named
ft("Named type");
type tInt int;

ft("Named type test");
type tInt int;
var x tInt;
assert(x, 0);


ft("Chained named type");
type tA bool;
type tB tA;
var x tB;
assert(x, false);

ft("Create and set named type");
type t string;
var d t;
assert(d, "");
d = "str";
assert(d, "str");

ft("Create and set differently named types");
type t int;
var x1 t;
x1 = 101;
var x2 int;
x2 = x1;
assert(x1, 101);
assert(x2, 101);
var xA int;
xA = 42;
var xB t;
xB = xA;
assert(xA, 42);
assert(xB, 42);

ft("Create and set two named types derived from int");
type tA int;
type tB int;
var vA tA;
var vB tB;
vA = vB;

ft("Xtra--named");
type tA int;
type tB tA;
type tC tB;
var vA tA;
var vB tB;
var vC tC;
vA = vB;
vB = vA;
vA = vC;
vC = vA;
vB = vC;
vC = vB;


ft("Short declaration and named");
s := 101;
type t int;
var x t;
x = s;
s = x;
assert(x, s);
assert(s, 101);

ft("Named slice");
type ts []int;
type tsa []ts;

var v tsa;
v[0][0] = 42;
assert(v[0][0], 42);


ft("Named tuple");
type t (int, int);
var v t;
v[0] = 105;
assert(v[0], 105);
type t2 (t, int);
var v2 t2;
assert(len(v2), 2);
assert(v2[1], 0);




ft("Named");
type t [2]int;
var v t;

v[0] = 42;
var v2 [2]int;
v2 = v;
v = v2;

ft("Stress--named array");
type tA [3][2][3][2]decimal;
type tB [2][5]tA;
type tC [2]tA;
var vA tA;
var vB tB;
var vC tC;




ft("Sprint");
sprint("");


//Printing


ft("Print one item");
assert(stringValue(101), "101");

ft("Print multiple items");
assert(sprint(23, 42, 101), "23 42 101");


ft("Print literals IBS");
assert(sprint(42, true, "str"), "42 true str");

ft("Print arrays");
assert(sprint([23], [true, true], ["aa", "bb", "cc"]), "[23] [true true] [aa bb cc]");

ft("Print slices");
assert(sprint(...[10], ...[23, 45], ...["ab", "bc"]), "[10] [23 45] [ab bc]");

ft("Print tuple");
assert(sprint((1, true, 10.5)), "(1 true 10.5)");

ft("Print pointer");
assert(sprint(*(5, *(), true)), "*(5 *() true)");

ft("Print single element object");
assert(sprint({"foo": 42}), "{foo:42}");






ft("Print");
assert(sprint(""), "");

ft("Print zero");
assert(sprint(0), "0");

ft("Mixed");
assert(sprint(1, 2) + sprint(3), "1 23");

ft("Print str");
assert(sprint("str"), "str");

ft("Print var");
var x int;
x = 23;
assert(sprint(x), "23");






ft("Recursive named");
type node *(node, bool);
var n node;
assert(n, *());

n = *(*(), true);
assert(len(n), 2);
assert(n[0], *());
assert(n[1], true);












ft("Short slice equals");
s := ...[5];
a := ...[5];
a = s;
a = ...[10];


ft("Nested types, declared");
var cdn42 [3][]bool;
var cdns42 []bool;
cdns42[0] = true;
cdn42[0] = cdns42;

ft("Short declaration slice");
sda := ...[10, 23, 42, 101];

assert(stringValue(sda), "[10 23 42 101]");
var sds []int;

sds = sda;
assert(stringValue(sds), "[10 23 42 101]");

ft("Short declaration nested slice");
sdns := ...[...[2, 1], ...[21, 23, 101]];
var sdns2 [][]int;
sdns2 = sdns;



ft("Slicing can be repeated and still shares both ways");
s := ...[101, 42];
s2 := s[:][:][:];
s2[0] = 201;
assert(s[0], 201);
s[1] = 301;
assert(s2[1], 301);

ft("Assign smaller slice to slice plus length");
assts := ...[24, 30, 101];
assts = [202, 302][:];
assert(len(assts), 2);

ft("Assign larger slice to slice plus length");
alsts := ...[24, 30];
alsts = ...[202, 302, 502];





ft("Pointer as nullable it:");
var pi *(int);
pi = *(42);

//Block
ft("Block");
{}

ft("Block 2");
{
    0;
}
{
    true;
}
{
    5;
    10;
    false;
}

   ft("Block nest");
{
    {}
}

   {
    {
        {
        }
    }
}

   ft("Blocks share scope");
{
    var x int;
}
x;










ft("Global int in header");
GLOB := 3;
func giih(ar [GLOB]bool) {
    assert(len(ar), 3);
}
var glob [GLOB] bool;
giih(glob);


ft("Array copies in call");
func arFunc(ar [1]int) {
    ar[0] = 42;
}
var arF[1]int;
arF[0] = 23;
arFunc(arF);


ft("Slice shares in call");
func slFunc(s []int) {
    s[0] = 201;
}
var slf []int;
slf = ...[23, 101];
slFunc(slf);


ft("Map shares in call");
func mFunc(m [map]int) {
    m["aap"] = 101;
}
mapShare := { "aap": 42};
mFunc(mapShare);


ft("Tuple");
var tup23 (int, bool, string);

ft("Tuple copies");
var tup (int, bool);
var tup2 (int, bool);
tup[0] = 42;
tup2 = tup;
tup2[1] = true;

ft("Tuple assignments");
var tup2 ([]int, []string);
tup2[0] = ...[3, 5];
tup2[1] = ["aap", "noot"][:];


ft("Tuple short declaration");
tup := (42, true, "str", 1.5);


ft("Set tuple");
tup := (42, true, "str", 1.5);
tup[0] = 23;
tup[1] = false;

ft("Postfix minus array tuple, map");
pfA := [50];
pfT := (101, "boo");
pfM := {"aaa": 23};
pfA[0]--;
assert(pfA[0], 49);
pfT[0]--;
assert(pfT[0], 100);
pfM["aaa"]--;
assert(pfM["aaa"], 22);


ft("Global ar");
gar := [1, 5];
func garf() {
    gar = [10, 12];
}

ft("Short declaration copies integer");
sdci1 := 5;
sdci2 := sdci1;
sdci1 = 10;


ft("Slicing shares");
ssAr1 := ...[1, 10, 101, 202];
ssAr2 := ssAr1[1@2];
ssAr2[0] = 777;

ft("Slice of arrays does not share (bug)");
var j [][1]int;
j[0] = [23];
var k [1]int;
k = j[0];
k[0] = 42;


ft("Slice to slice shares");
sss := ...[7, 23, 42];
sss2 := sss[:];
sss2[0] = 101;

ft("Array to slice copies (fix)");
ar := [7, 42];
s := ar[:];
s[0] = 101;

ft("Slice of arrays");
var soa [][2]int;

soa[0][1] = 42;
soa[1][0] = 101;
soa[1] = soa[0];
soa[0][0] = 202;

ft("Multi-dimensional array of int");
var mda [2][3]int;
mda[1][2] = 42;


ft("Multi-dimensional tuple");
var mdt ([5]int, (bool, int));
mdt[0][2] = 42;
mdt[1][1] = 101;
mdt[1][0] = true;



ft("Multi-dimensional tuple set compound type");
var mdt ([5]int, (bool, int));
mdt[0][2] = 42;
mdt[1][1] = 101;
mdt[1][0] = true;
var mdt2 ([5]int, (bool, int));
mdt[1] = (true, 202);






ft("Pointer compare");
x := *(4);
y := *(4);
z := y;
y[0] = 12;





ft("Assignability of recursive pointers");
var point1 *(int, self);
var point2 *(int, self);
point1 = *(42, *());
point2 = point1;
//print(point1, point2);

//point2 = *(101, point2);
//print(point1, point1[1], point2);

ft("Pointer shares");
var p *(int, int);
var p2 *(int, int);
p = *(23, 42);
p2 = p;
p2[0] = 101;

ft("Function copies pointer");
func f(p *(int)) {
  p = *(10);
}
func g(p *(int)) {
  p[0] = 202;
}
var z *(int);
z = *(23);
f(z);
g(z);


ft("Nested tuple short");
x := (4, (10, *(12, *())));
assert(x[0], 4);
//assert(x[0][0], 10); BUG


ft("Bubble sort");
bub := [1, 1081, 20, 101, 202];

var i int;
var j int;
for i = range 0:len(bub) - 1 {
    for j = len(bub) - 1; j > i; j-- {
      if bub[j] < bub[j - 1] {
        bub[j - 1], bub[j] = bub[j], bub[j - 1];
      }
    }
}
assert(bub, [1, 20, 101, 202, 1081]);




//ft("Binary search tree", "1 2 3 5 5 5 10 ");
//var i int;
//var mbst *(self, int, self);
//func tree_insert(x int) {
//    if mbst == *() {
//            mbst = *(*(), x, *());
//            return;
//    }
//        cur := mbst;
//        loop {
//            if i < cur[1] {
//                if cur[0] == *() {
//                    cur[0] = *(*(), i, *());
//                    break;
//                } else {
//                    cur = cur[0];
//                    continue;
//                }
//            } else if i >= cur[1] {
//                if cur[2] == *() {
//                    cur[2] = *(*(), i, *());
//                    break;
//                } else {
//                    cur = cur[2];
//                    continue;
//                }
//            }
//            debug();
//    }
//}
//for i = range [1, 5, 5, 5, 10, 2, 3] {
//    tree_insert(i);
//}
//func dfs(node  *(self, int, self)) {
//    if node == *() {
//        return;
//    }
//    dfs(node[0]);
//    print(node[1]);
//    dfs(node[2]);
//}
//dfs(mbst);
//


//ft("Linked list", "5 8 23 ");
//var LL *(int, self);
//LL = *(5, *());
//base := LL;
//
//LL[1] = *(8, *());
//
//LL = LL[1];
//LL[1] = *(23, *());
//func pll(node *(int, self)) {
//    if node == *() {
//        return;
//    }
//    print(node[0]);
//    pll(node[1]);
//}
//pll(base);
//


//ft("Doubly linked list");
//var dll *(self, int, self);
//dll = *(*(), 5, *());
//dll[2] = *(dll, 7, *());




ft("");











































ft("Named type test");
type tInt int;
var x tInt;
x = 5;
assert(x, 5);



ft("Named type tuple string");
type tTuple (string, string);
var x tTuple;
x[0] = "a";
x[1] = "b";

ft("Named type equality");
type tInt int;
var x tInt;
var y tInt;
x = 12;
y = x;

ft("Classify");
var t *(*(*(bool), int), int);
t = *(*(*(), 42), 101);
//print(t, t[0], t[0][0]);
var t2 *(self, int);
t2 = *(*(*(), 42), 101);
//print(t2, t2[0], t2[0][0]);

ft("len");
assert(len("abc"), 3);

ft("Compound + - * % /");
var comp int;
comp = 5;
comp += 2;
assert(comp, 7);
comp -= 3;
assert(comp, 4);
comp *= 2;
assert(comp, 8);
comp %= 3;
assert(comp, 2);
comp /= 2;
assert(comp, 1);

ft("Order of ops", "9 7");
assert(1 + 2 * 3, 9);
assert(1 + (2 * 3), 7);
